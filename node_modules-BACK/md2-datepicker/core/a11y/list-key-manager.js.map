{"version":3,"sources":["core/a11y/list-key-manager.ts"],"names":[],"mappings":"OACO,EAAC,QAAQ,EAAE,UAAU,EAAE,GAAG,EAAC,MAAM,SAAS;OAE1C,EAAC,OAAO,EAAC,MAAM,cAAc;AAWpC;;;GAGG;AACH;IAIE,wBAAoB,MAA8B;QAA9B,WAAM,GAAN,MAAM,CAAwB;QAF1C,YAAO,GAAiB,IAAI,OAAO,EAAE,CAAC;IAEO,CAAC;IAMtD,sBAAI,kCAAM;QAJV;;;WAGG;aACH;YACE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;QACrC,CAAC;;;OAAA;IAED,sBAAI,4CAAgB;aAApB;YACE,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;QAChC,CAAC;aAED,UAAqB,KAAa;YAChC,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;QACjC,CAAC;;;OAJA;IAMD,kCAAS,GAAT,UAAU,KAAoB;QAC5B,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,UAAU,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,cAAc,EAAE,CAAC;QACxB,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,QAAQ,CAAC,CAAC,CAAC;YACtC,IAAI,CAAC,kBAAkB,EAAE,CAAC;QAC5B,CAAC;QAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,KAAK,GAAG,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1B,CAAC;IACH,CAAC;IAEO,uCAAc,GAAtB;QACE,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACpC,IAAI,CAAC,uBAAuB,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QACvC,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,KAAK,EAAE,CAAC;IACxC,CAAC;IAEO,2CAAkB,GAA1B;QACE,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACpC,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QACxC,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,KAAK,EAAE,CAAC;IACxC,CAAC;IAED;;;;;;;OAOG;IACK,gDAAuB,GAA/B,UAAgC,KAAa,EAAE,KAAoB;QACjE,wDAAwD;QACxD,IAAI,CAAC,iBAAiB;YACpB,CAAC,IAAI,CAAC,iBAAiB,GAAG,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;QAEjE,+DAA+D;QAC/D,wDAAwD;QACxD,OAAO,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,QAAQ,EAAE,CAAC;YAC9C,IAAI,CAAC,uBAAuB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC7C,CAAC;IACH,CAAC;IAEH,qBAAC;AAAD,CAhEA,AAgEC,IAAA","file":"list-key-manager.js","sourcesContent":["import {QueryList} from '@angular/core';\r\nimport {UP_ARROW, DOWN_ARROW, TAB} from '../core';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Subject} from 'rxjs/Subject';\r\n\r\n/**\r\n * This is the interface for focusable items (used by the ListKeyManager).\r\n * Each item must know how to focus itself and whether or not it is currently disabled.\r\n */\r\nexport interface MdFocusable {\r\n  focus(): void;\r\n  disabled?: boolean;\r\n}\r\n\r\n/**\r\n * This class manages keyboard events for selectable lists. If you pass it a query list\r\n * of focusable items, it will focus the correct item when arrow events occur.\r\n */\r\nexport class ListKeyManager {\r\n  private _focusedItemIndex: number;\r\n  private _tabOut: Subject<any> = new Subject();\r\n\r\n  constructor(private _items: QueryList<MdFocusable>) {}\r\n\r\n  /**\r\n   * Observable that emits any time the TAB key is pressed, so components can react\r\n   * when focus is shifted off of the list.\r\n   */\r\n  get tabOut(): Observable<void> {\r\n    return this._tabOut.asObservable();\r\n  }\r\n\r\n  get focusedItemIndex(): number {\r\n    return this._focusedItemIndex;\r\n  }\r\n\r\n  set focusedItemIndex(value: number) {\r\n    this._focusedItemIndex = value;\r\n  }\r\n\r\n  onKeydown(event: KeyboardEvent): void {\r\n    if (event.keyCode === DOWN_ARROW) {\r\n      this._focusNextItem();\r\n    } else if (event.keyCode === UP_ARROW) {\r\n      this._focusPreviousItem();\r\n    } else if (event.keyCode === TAB) {\r\n      this._tabOut.next(null);\r\n    }\r\n  }\r\n\r\n  private _focusNextItem(): void {\r\n    const items = this._items.toArray();\r\n    this._updateFocusedItemIndex(1, items);\r\n    items[this._focusedItemIndex].focus();\r\n  }\r\n\r\n  private _focusPreviousItem(): void {\r\n    const items = this._items.toArray();\r\n    this._updateFocusedItemIndex(-1, items);\r\n    items[this._focusedItemIndex].focus();\r\n  }\r\n\r\n  /**\r\n   * This method sets focus to the correct item, given a list of items and the delta\r\n   * between the currently focused item and the new item to be focused. It will\r\n   * continue to move down the list until it finds an item that is not disabled, and it will wrap\r\n   * if it encounters either end of the list.\r\n   *\r\n   * @param delta the desired change in focus index\r\n   */\r\n  private _updateFocusedItemIndex(delta: number, items: MdFocusable[]) {\r\n    // when focus would leave menu, wrap to beginning or end\r\n    this._focusedItemIndex =\r\n      (this._focusedItemIndex + delta + items.length) % items.length;\r\n\r\n    // skip all disabled menu items recursively until an active one\r\n    // is reached or the menu closes for overreaching bounds\r\n    while (items[this._focusedItemIndex].disabled) {\r\n      this._updateFocusedItemIndex(delta, items);\r\n    }\r\n  }\r\n\r\n}\r\n"]}